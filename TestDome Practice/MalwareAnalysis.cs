using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TestDomePractice
{
/*
    
Your company is analyzing malware which targets numerical record files.

The malware uses a sliding window over the array of numbers in a file, and tries to match the following
pattern:

Tl, -, -, X, -, -, -, Tr

The entire window is moved so that 'X' passes through all the values and is compared to the numbers at
the 'Tl' and 'Tr' locations, which are positioned at a constant offset to 'X'

The malware has the following rules:

• If the value at the 'Tl' or 'Tr' position of the pattern is bigger or equal to the value at the 'X' position, the
malware replaces the value at 'X' with O.

• If the value at the 'Tl' or 'Tr' offset is out of bounds, then the value at 'X' is only compared to the other
existing value.

• The record is processed in two stages: first, all the positions that should be set to 0 are located, using
the original values for comparison. Only after all positions have been identified do they get set to 0.

For example, if the values in a record file are the following:

new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3}

The expected values after the malware runs are:

new int[] { 1, 0, 0, 5, 0, 0, 0, 3, 3, 0}

In this example, both '2's, the '4' and the last '3' were replaced by 0.

Implement the Simulate method so that the malware behavior is replicated for further study.

*/


    internal static class MalwareAnalysis
    {
        // Go through each value within 'entries' and perform the Tl and Tr check.
        // If the check passes, add the index to the list
        // After all checks completed, update the index locations to 0.

        public static int[] Simulate(int[] entries)
        {
            var leftOffset = 3;
            var rightOffset = 4;

            var indexesToChange = new List<int>();

            for (int i = 0; i < entries.Length; i++)
            {
                var TlPosition = i - leftOffset;

                if (TlPosition >= 0 && TlPosition < entries.Length)
                {
                    if (entries[TlPosition] >= entries[i])
                    {
                        indexesToChange.Add(i);
                    }
                }

                var TrPosition = i + rightOffset;

                if (TrPosition >= 0 && TrPosition < entries.Length)
                {
                    if (entries[TrPosition] >= entries[i])
                    {
                        indexesToChange.Add(i);
                    }
                }
            }

            foreach (var index in indexesToChange)
            {
                entries[index] = 0;
            }

            return entries;
        }

        public static void Main_MalwareAnalysis()
        {
            int[] records = new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
            var result = Simulate(records);
            Console.WriteLine(string.Join(", ", result));
        }
    }
}
